<script>
// === PATCH: substitua a função fetchTopFactionGlobal inteira por esta ===
async function fetchTopFactionGlobal(){
  // 1) Tenta agregar direto no PostgREST (conta vitórias por facção)
  try{
    const { data, error } = await supabase
      .from('game_players')
      // Ao selecionar "faction" junto de "count()", o PostgREST já faz GROUP BY automaticamente.
      .select('faction, wins:count()')
      .eq('winner', true)
      .order('wins', { ascending: false })
      .limit(1);

    if (error) throw error;
    if (data && data.length) {
      const row = data[0];
      return { faction: row.faction, wins: Number(row.wins) || 0 };
    }
  }catch(err){
    console.warn('[TopFaction] aggregate failed, falling back to client count:', err);
  }

  // 2) Fallback: carrega em páginas e conta no cliente (não usa group nem agregação)
  const pageSize = 2000;
  let from = 0;
  const counts = {};
  while(true){
    const { data, error } = await supabase
      .from('game_players')
      .select('faction')
      .eq('winner', true)
      .range(from, from + pageSize - 1);

    if (error) { console.error('[TopFaction] fallback error:', error); break; }
    if (!data || data.length === 0) break;

    for (const r of data){
      const key = canonFactionName(r.faction);
      if (!key) continue;
      counts[key] = (counts[key] || 0) + 1;
    }
    if (data.length < pageSize) break;
    from += data.length;
  }

  const entries = Object.entries(counts);
  if (!entries.length) return null;
  entries.sort((a,b)=> b[1]-a[1]);
  const [faction, wins] = entries[0];
  return { faction, wins };
}
</script>
